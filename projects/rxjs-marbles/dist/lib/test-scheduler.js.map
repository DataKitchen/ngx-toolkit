{"version":3,"file":"test-scheduler.js","sourceRoot":"","sources":["../../lib/test-scheduler.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,aAAa,IAAI,iBAAiB,EAAE,MAAM,cAAc,CAAC;AAGlE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAuCG;AACH,MAAM,OAAO,aAAc,SAAQ,iBAAiB;IAIlD,MAAM,CAAC,OAAO,CAAI,UAAyB;QACzC,MAAM,SAAS,GAAG,IAAI,aAAa,EAAE,CAAC;QACtC,OAAO,SAAS,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;IACvC,CAAC;IAED;QACE,KAAK,CAAC,CAAC,MAAM,EAAE,QAAQ,EAAE,EAAE;YACzB,IAAI,IAAI,CAAC,UAAU,EAAE;gBACnB,KAAK,MAAM,eAAe,IAAI,QAAQ,EAAE;oBACtC,MAAM,CAAC,MAAM,CAAC,CAAC,cAAc,CAAC,eAAe,CAAC,CAAC;iBAChD;aACF;iBAAM;gBACL,MAAM,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;aAClC;QACH,CAAC,CAAC,CAAC;QAjBL,eAAU,GAAG,KAAK,CAAC;QACX,aAAQ,GAAG,CAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAE,CAAC;IAiBxJ,CAAC;IAED,OAAO,CAAI,UAAyB;QAMlC,yBAAyB;QACzB,IAAI,CAAC,UAAU,GAAG,KAAK,CAAC;QAExB,OAAO;YACL,IAAI,EAAE,CAAC,OAAe,EAAE,MAAY,EAAE,UAAgB,EAAE,EAAE;gBACxD,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,gBAAgB,EAAE,EAAE,EAAE;oBAChC,gBAAgB,CAAC,UAAU,CAAC,CAAC,IAAI,CAAC,OAAO,EAAE,MAAM,EAAE,UAAU,CAAC,CAAC;gBACjE,CAAC,CAAC,CAAC;YACL,CAAC;YACD,OAAO,EAAE,CAAC,GAAG,EAAE,EAAE;gBACf,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,gBAAgB,EAAE,EAAE,EAAE;oBAChC,gBAAgB,CAAC,UAAU,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;gBAC5C,CAAC,CAAC,CAAC;YACL,CAAC;YACD,SAAS,EAAE,CAAC,GAAG,MAAa,EAAE,EAAE;gBAE9B,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;gBAEvB,IAAI,CAAC,GAAG,CAAC,CAAC,EAAC,gBAAgB,EAAC,EAAE,EAAE;oBAE9B,MAAM,MAAM,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,KAAK,EAAE,EAAE;wBACrC,OAAO,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;oBAC9B,CAAC,CAAC,CAAC;oBAEH,MAAM,CAAC,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,KAAK,EAAE,EAAE;wBAC1C,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,GAAG,GAAG,CAAC;wBAChC,OAAO,GAAG,CAAC;oBACb,CAAC,EAAE,EAAE,CAAC,CAAC;oBAEP,gBAAgB,CAAC,UAAU,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;gBACxD,CAAC,CAAC,CAAC;YACL,CAAC;SACF,CAAC;IAEJ,CAAC;CACF","sourcesContent":["import { TestScheduler as RxJsTestScheduler } from 'rxjs/testing';\nimport { Observable } from 'rxjs';\n\n/**\n * Syntactic sugar for rxjs's TestScheduler.\n *\n * In the where a global `scheduler` is needed in a test, and this is especially\n * true when time operators are used, inject the `testScheduler` creating a new\n * instance.\n *\n * Then use `testScheduler.run` or `testScheduler.observable$`\n *\n * The former being the same as the original, while the latter is a shorthand\n * for when no callback is needed to directly use `expectObservable`\n *\n * @example\n *  let testScheduler: TestScheduler;\n *\n *  beforeEach(() => {\n *     testScheduler = new TestScheduler();\n *\n *     TestBed.configureTestingModule({\n *       providers: [\n *         {\n *           provide: rxjsScheduler,\n *           useValue: testScheduler,\n *         }\n *       ],\n *     });\n *\n *   });\n *\n *   it('should check on observable', () => {\n *     testScheduler.expect$(of(1)).toEqual(of(1));\n *   })\n *\n *   it('should check in a callback', () => {\n *     testScheduler.run(({expectObservable}) => {\n *       // actions\n *       expectObservable(of(1)).toEqual(of(1));\n *     });\n *   })\n */\nexport class TestScheduler extends RxJsTestScheduler {\n  useContain = false;\n  private alphabet = [ 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z' ];\n\n  static expect$<T>(observable: Observable<T>) {\n    const scheduler = new TestScheduler();\n    return scheduler.expect$(observable);\n  }\n\n  constructor() {\n    super((actual, expected) => {\n      if (this.useContain) {\n        for (const expectedElement of expected) {\n          expect(actual).toContainEqual(expectedElement);\n        }\n      } else {\n        expect(actual).toEqual(expected);\n      }\n    });\n  }\n\n  expect$<T>(observable: Observable<T>): {\n    toBe(marbles: string, values?: any, errorValue?: any): void;\n    toEqual: (other: Observable<T>) => void;\n    toContain: (...values: any[]) => void;\n  } {\n\n    // reset use contain flag\n    this.useContain = false;\n\n    return {\n      toBe: (marbles: string, values?: any, errorValue?: any) => {\n        this.run(({ expectObservable }) => {\n          expectObservable(observable).toBe(marbles, values, errorValue);\n        });\n      },\n      toEqual: (obs) => {\n        this.run(({ expectObservable }) => {\n          expectObservable(observable).toEqual(obs);\n        });\n      },\n      toContain: (...values: any[]) => {\n\n        this.useContain = true;\n\n        this.run(({expectObservable}) => {\n\n          const marble = values.map((_, index) => {\n            return this.alphabet[index];\n          });\n\n          const v = values.reduce((acc, val, index) => {\n            acc[this.alphabet[index]] = val;\n            return acc;\n          }, {});\n\n          expectObservable(observable).toBe(marble.join(''), v);\n        });\n      }\n    };\n\n  }\n}\n"]}